# Understanding a BPF program

Let's examine the program generated by `tcpdump -i en1 port 22 -d` and attempt
to understand it. First of all, let's see what we expect the program generated
by `port 22` to do. Probably it's going to filter all IP traffic with port
number is 22.

So let's take a look.

## The full program

```
(000) ldh      [12]
(001) jeq      #0x86dd          jt 2	jf 10
(002) ldb      [20]
(003) jeq      #0x84            jt 6	jf 4
(004) jeq      #0x6             jt 6	jf 5
(005) jeq      #0x11            jt 6	jf 23
(006) ldh      [54]
(007) jeq      #0x16            jt 22	jf 8
(008) ldh      [56]
(009) jeq      #0x16            jt 22	jf 23
(010) jeq      #0x800           jt 11	jf 23
(011) ldb      [23]
(012) jeq      #0x84            jt 15	jf 13
(013) jeq      #0x6             jt 15	jf 14
(014) jeq      #0x11            jt 15	jf 23
(015) ldh      [20]
(016) jset     #0x1fff          jt 23	jf 17
(017) ldxb     4*([14]&0xf)
(018) ldh      [x + 14]
(019) jeq      #0x16            jt 22	jf 20
(020) ldh      [x + 16]
(021) jeq      #0x16            jt 22	jf 23
(022) ret      #262144
(023) ret      #0
```

## The annotated program

    (000) ldh      [12]
    (001) jeq      #0x86dd          jt 2	jf 10

Whenever we see a literal value used in an equality comparison, it's seems like
a pretty safe bet that the constant will appear in a header file. We can use
`grep -r 0x86dd /usr/include` to learn that this constant is
`ETHERTYPE_IPV6 := 0x86dd` (see `net/ethernet.h` on MacOS).

So these statements load address 12 in the packet and check that it contains the
protocol identifier for IPv6. If so it jumps to statement 2 (the next statement),
otherwise it jumps to statement 10 below.

    (002) ldb      [20]
    (003) jeq      #0x84            jt 6	jf 4
    (004) jeq      #0x6             jt 6	jf 5
    (005) jeq      #0x11            jt 6	jf 23

`grep` tells us that these constants (in decimal) appear in `netinet/in.h` as
`IPPROTO_SCTP`, `IPPROTO_TCP`, and `IPPROTO_UDP`.

    (006) ldh      [54]
    (007) jeq      #0x16            jt 22	jf 8
    (008) ldh      [56]
    (009) jeq      #0x16            jt 22	jf 23

`0x16` is 22 in octal. Probably we're checking the source port and destination
port fields. If they match we jump to 22 (which accepts the packet), otherwise
we'll end up at statement 23 (which rejects the packet).

---

We get to statement 10 by jumping after we discover that this is *not* an IPv6
packet. Register A still contains the value we loaded at statement 0.

    (010) jeq      #0x800           jt 11	jf 23

We can probably guess that this is a check for a IPv4 packet. We can confirm
that by consulting `net/ethernet.h` where we find `ETHERTYPE_IP := 0x0800`.

    (011) ldb      [23]
    (012) jeq      #0x84            jt 15	jf 13
    (013) jeq      #0x6             jt 15	jf 14
    (014) jeq      #0x11            jt 15	jf 23

Compare the value to `IPPROTO_SCTP := 132`, `IPPROTO_TCP := 6`, or 
`IPPROTO_UDP := 17`. If it is none of these we'll jump to statement 23 (where
we reject the packet). Otherwise we'll continue to the next statement.

    (015) ldh      [20]
    (016) jset     #0x1fff          jt 23	jf 17
    (017) ldxb     4*([14]&0xf)
    (018) ldh      [x + 14]
    (019) jeq      #0x16            jt 22	jf 20
    (020) ldh      [x + 16]
    (021) jeq      #0x16            jt 22	jf 23
    (022) ret      #262144
    (023) ret      #0
