\documentclass[a4paper]{article}
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%


\usepackage{lmodern}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp} % provides euro and other symbols

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bbold}
\usepackage{color}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{microtype}
\usepackage{parskip}
\usepackage{tikz-cd}
\usepackage{upquote}
\usepackage{url}

\usepackage[backend=biber,style=trad-abbrv]{biblatex}
\usepackage[hidelinks,pdftex,unicode]{hyperref}

\usepackage{mathtools}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript

\urlstyle{same}
\UseMicrotypeSet[protrusion]{basicmath}

\addbibresource{presentation.bib}

\usepackage{tikz}
\usetikzlibrary{calc,shapes.multipart,chains,arrows}

\title{Efficient evaluation of pure calculi}
\author{Thomas Sutton}
\date{6 March 2019}

\hypersetup{
  pdftitle={Efficient evaluation of pure calculi},
  pdfauthor={Thomas Sutton}
}

\begin{document}
\maketitle

\begin{abstract}
Executing programs by direct interpretation of abstract syntax trees is
fundamentally inefficient. In this talk I'll discuss a family of abstract
machines for evaluating pure functional languages. Evaluators based on these
machines are more efficient than direct interpretation but still very simple.
\end{abstract}

\section{Introduction}


\section{A $\lambda$-calculus with names}

We're probably all familiar with the $\lambda$-calculus by now. Here's a standard
presentation.

Each \text{\tt Term}s of the $\lambda$-calculus is either:

\begin{itemize}
\item A lambda abstraction (i.e. function defininition)
\item An application of one term to another (i.e. a function invocation)
\item A variable
\end{itemize}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{41}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Term}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}{}\<[6]%
\>[6]{}\Conid{Var}\;{}\<[11]%
\>[11]{}\{\mskip1.5mu \Varid{varName}{}\<[22]%
\>[22]{}\mathbin{::}\Conid{Name}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid {}\<[6]%
\>[6]{}\Conid{Abs}\;{}\<[11]%
\>[11]{}\{\mskip1.5mu \Varid{absName}{}\<[22]%
\>[22]{}\mathbin{::}\Conid{Name},{}\<[32]%
\>[32]{}\Varid{absBody}{}\<[41]%
\>[41]{}\mathbin{::}\Conid{Term}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid {}\<[6]%
\>[6]{}\Conid{App}\;{}\<[11]%
\>[11]{}\{\mskip1.5mu \Varid{appFun}{}\<[22]%
\>[22]{}\mathbin{::}\Conid{Term},{}\<[32]%
\>[32]{}\Varid{appArg}{}\<[41]%
\>[41]{}\mathbin{::}\Conid{Term}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{deriving}\;(\Conid{Show},\Conid{Eq},\Conid{Ord}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can evaluate these terms by substitution -- when we pass through a binder
during the evaluation process we replace all free instances of the bound name
in the body with the argument value.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{subst}\mathbin{::}\Conid{Name}\to \Conid{Term}\to \Conid{Term}\to \Conid{Term}{}\<[E]%
\\
\>[B]{}\Varid{subst}\;\Varid{tgt}\;\Varid{val}\mathrel{=}\Varid{rec}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{rec}\;\Varid{term}\mathrel{=}\mathbf{case}\;\Varid{term}\;\mathbf{of}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Var}\;\Varid{name}{}\<[22]%
\>[22]{}\mid \Varid{tgt}\equiv \Varid{name}{}\<[37]%
\>[37]{}\to \Varid{val}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Var}\;\Varid{name}{}\<[22]%
\>[22]{}\mid \Varid{otherwise}{}\<[37]%
\>[37]{}\to \Varid{term}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Abs}\;\Varid{name}\;\Varid{body}{}\<[22]%
\>[22]{}\mid \Varid{tgt}\equiv \Varid{name}{}\<[37]%
\>[37]{}\to \Varid{term}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Abs}\;\Varid{name}\;\Varid{body}{}\<[22]%
\>[22]{}\mid \Varid{otherwise}{}\<[37]%
\>[37]{}\to \Conid{Abs}\;\Varid{name}\;(\Varid{rec}\;\Varid{body}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{App}\;\Varid{fun}\;\Varid{arg}{}\<[37]%
\>[37]{}\to \Conid{App}\;(\Varid{rec}\;\Varid{fun})\;(\Varid{rec}\;\Varid{arg}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Evaluation by substitution is very straightforward:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{eval}\mathbin{::}\Conid{Term}\to \Conid{Either}\;\Conid{String}\;\Conid{Term}{}\<[E]%
\\
\>[B]{}\Varid{eval}\;\Varid{term}\mathrel{=}\mathbf{case}\;\Varid{term}\;\mathbf{of}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Abs}\;\anonymous \;\anonymous {}\<[28]%
\>[28]{}\to \Conid{Right}\;\Varid{term}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Var}\;\Varid{name}{}\<[28]%
\>[28]{}\to \Conid{Left}\;(\text{\tt \char34 Free~variable:~\char34}\plus \Varid{name}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{App}\;(\Conid{Abs}\;\Varid{name}\;\Varid{body})\;\Varid{arg}{}\<[28]%
\>[28]{}\to \Varid{eval}\;(\Varid{subst}\;\Varid{name}\;\Varid{arg}\;\Varid{body}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{App}\;\anonymous \;\anonymous {}\<[28]%
\>[28]{}\to \Conid{Left}\;(\text{\tt \char34 Can't~apply~non-function:~\char34}\plus \Varid{show}\;\Varid{term}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This is very straightforward and works perfectly well but it's also very
inefficient: every time evaluate an application, you rewrite the leaves of the
tree. You can improve constant factors (e.g. skipping sub-terms that do not
contain the target variable) but this is still fundamentally inefficient.


\section{A $\lambda$-calculus with de Bruijn indices}

Another style of lambda calculus presentation replaces variable names with
indices into a data structure -- when we encounter a variable (index) we can
tell how many levels "outward" to go to find the binder that introduced that
variable: the variable $\mathbb{1}$ is the variable introducted by first
binder, the variable $\mathbb{2}$ by the next, etc.

$\lambda x. \lambda y. \lambda z. y = \lambda \lambda \lambda 2$

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Term}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Conid{Var}\;\Conid{Nat}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{Abs}\;\Conid{Term}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{App}\;\Conid{Term}\;\Conid{Term}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{deriving}\;(\Conid{Show},\Conid{Eq}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\section{Compiling named terms to indexed terms}

We can convert closed terms of a named $\lambda$-calculus to terms with de
Bruijn indices by traversing the term with a map of names to indicies.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{compile}\mathbin{::}\Conid{\Conid{LC}.Term}\to \Conid{Either}\;[\mskip1.5mu \Conid{String}\mskip1.5mu]\;\Conid{\Conid{DB}.Term}{}\<[E]%
\\
\>[B]{}\Varid{compile}\;\Varid{t}\mathrel{=}\Conid{Right}\;(\Varid{evalState}\;(\Varid{comp}\;\Varid{t})\;\Varid{mempty}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{comp}\mathbin{::}\Conid{\Conid{LC}.Term}\to \Conid{State}\;(\Conid{Map}\;\Conid{Name}\;\Conid{Nat})\;\Conid{\Conid{DB}.Term}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{comp}\;(\Conid{\Conid{LC}.Var}\;\Varid{n}){}\<[24]%
\>[24]{}\mathrel{=}(\Conid{\Conid{DB}.Var}\mathbin{\circ}\Varid{fromJust})\mathbin{<\hspace{-1.6pt}\mathclap{\raisebox{0.1pt}{\scalebox{.8}{\$}}}\hspace{-1.6pt}>}(\Varid{gets}\;(\Varid{\Conid{M}.lookup}\;\Varid{n})){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{comp}\;(\Conid{\Conid{LC}.Abs}\;\Varid{n}\;\Varid{v}){}\<[24]%
\>[24]{}\mathrel{=}\Conid{\Conid{DB}.Abs}\mathbin{<\hspace{-1.6pt}\mathclap{\raisebox{0.1pt}{\scalebox{.8}{\$}}}\hspace{-1.6pt}>}(\Varid{scoped}\;\Varid{n}\;(\Varid{comp}\;\Varid{v})){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{comp}\;(\Conid{\Conid{LC}.App}\;\Varid{m}\;\Varid{n}){}\<[24]%
\>[24]{}\mathrel{=}\Conid{\Conid{DB}.App}\mathbin{<\hspace{-1.6pt}\mathclap{\raisebox{0.1pt}{\scalebox{.8}{\$}}}\hspace{-1.6pt}>}\Varid{comp}\;\Varid{m}\mathbin{<*>}\Varid{comp}\;\Varid{n}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{scoped}\mathbin{::}\Conid{Name}\to \Conid{State}\;(\Conid{Map}\;\Conid{Name}\;\Conid{Nat})\;\Varid{a}\to \Conid{State}\;(\Conid{Map}\;\Conid{Name}\;\Conid{Nat})\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{scoped}\;\Varid{n}\;\Varid{m}\mathrel{=}\mathbf{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{s}\leftarrow \Varid{get}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{put}\;(\Varid{\Conid{M}.insert}\;\Varid{n}\;\mathrm{1}\;(\Varid{\Conid{M}.map}\;(\mathbin{+}\mathrm{1})\;\Varid{s})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{r}\leftarrow \Varid{m}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{put}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\;\Varid{r}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\newcommand{\mconfig}[3]{\langle #1 \:\vert\: #2 \:\vert\: #3 \rangle}
\newcommand{\lvar}[1]{\mathbb{#1}}
\newcommand{\labs}[1]{\lambda.#1}
\newcommand{\lapp}[2]{(#1 \: #2)}
\newcommand{\mclosure}[2]{[#2]#1}

\section{The Krivine machines}

Krivine machines are a family of abstract machines for the efficient evaluation
of $\lambda$-calculi. The exact structure of the machine depends on the language
features, evaluation semantics, etc. First we'll look at a simple machine for
lazy evaluation (like the evaluator we looked at previously).

The a configuration of the machine has three parts:

\begin{itemize}
\item the current {\it environment}
\item the current {\it term}
\item a {\it stack} of suspended terms
\end{itemize}

Each item in the {\it environment} and the {\it stack} is a closure containing
an unevaluated term and the environment needed to evaluate that term. These are
more or less equivalent to Haskell's "thunks" (excepting that these closures
cannot be updated with the result and aren't shared).

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}c<{\hspost}@{}}%
\column{18E}{@{}l@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Closure}\mathrel{=}\Conid{Closure}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\{\mskip1.5mu {}\<[6]%
\>[6]{}\Varid{closureTerm}{}\<[19]%
\>[19]{}\mathbin{::}\Conid{Term}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},{}\<[6]%
\>[6]{}\Varid{closureEnv}{}\<[19]%
\>[19]{}\mathbin{::}[\mskip1.5mu \Conid{Closure}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Conid{State}\mathrel{=}\Conid{State}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\{\mskip1.5mu \Varid{environment}{}\<[18]%
\>[18]{}\mathbin{::}{}\<[18E]%
\>[22]{}[\mskip1.5mu \Conid{Closure}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{term}{}\<[18]%
\>[18]{}\mathbin{::}{}\<[18E]%
\>[22]{}\Conid{Term}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{suspended}{}\<[18]%
\>[18]{}\mathbin{::}{}\<[18E]%
\>[22]{}[\mskip1.5mu \Conid{Closure}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We'll evaluate an application by stashing the argument sub-term in the {\it stack}
of closures and continuing evaluation with the function sub-term.

$$
\frac{
  \mconfig{p}{\lapp{M}{N}}{s}
}{
  \mconfig{p}{M}{\mclosure{N}{p} : s}
}
$$

We'll evaluate an abstraction by moving the most-recently suspended closure from
the {\it stack} to the {\it environment} and continue evaluation with the
function body {\it term}.

$$
\frac{
  \mconfig{p}{\labs{M}}{u : s}
}{
  \mconfig{u : p}{M}{s}
}
$$

We'll evaluate a variable by dropping that many closures from the front of the
{\it environment} and continuing evaluation with the last of them. (E.g. for
variable $\mathbb{1}$ we'll drop one item and continue evaluation with it,
for $\mathbb{2}$ we'll drop two and continue with the second of them, etc.)

$$
\frac{
  \mconfig{\mclosure{t}{v}:p}{\lvar{1}}{s}
}{
  \mconfig{v}{t}{s}
}
$$

$$
\frac{
  \mconfig{v : p}{\lvar{N}}{s}
}{
  \mconfig{p}{\lvar{N - 1}}{s}
}
$$

We should be able to convince outselves of two things:

\begin{enumerate}
\item any closed term with a normal form can be evaluated by this machine
\item it's more efficient than it was.
\end{enumerate}


\appendix


\section{Parsing $\lambda$-calculus terms with names}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Ctx}\mathrel{=}([\mskip1.5mu \Conid{Name}\mskip1.5mu],[\mskip1.5mu \Conid{Name}\mskip1.5mu]){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{type}\;\Conid{Parser}\mathrel{=}\Conid{Parsec}\;\Conid{String}\;\Conid{Ctx}\;\Conid{Term}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{getScope}\mathbin{::}\Conid{Parsec}\;\Conid{String}\;\Conid{Ctx}\;[\mskip1.5mu \Conid{Name}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{getScope}\mathrel{=}\Varid{fst}\mathbin{<\hspace{-1.6pt}\mathclap{\raisebox{0.1pt}{\scalebox{.8}{\$}}}\hspace{-1.6pt}>}\Varid{getState}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{modifyScope}\mathbin{::}([\mskip1.5mu \Conid{Name}\mskip1.5mu]\to [\mskip1.5mu \Conid{Name}\mskip1.5mu])\to \Conid{Parsec}\;\Conid{String}\;\Conid{Ctx}\;(){}\<[E]%
\\
\>[B]{}\Varid{modifyScope}\;\Varid{f}\mathrel{=}\Varid{modifyState}\;(\lambda (\Varid{x},\Varid{y})\to (\Varid{f}\;\Varid{x},\Varid{y})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{parseName}\mathbin{::}\Conid{Parsec}\;\Conid{String}\;\Varid{u}\;\Conid{Name}{}\<[E]%
\\
\>[B]{}\Varid{parseName}\mathrel{=}\Varid{many1}\;(\Varid{letter}\mathbin{<|>}\Varid{char}\;\text{\tt '\char92 ''}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{parseAbs}\mathbin{::}\Conid{Parser}\to \Conid{Parser}{}\<[E]%
\\
\>[B]{}\Varid{parseAbs}\;\Varid{parseTerm}\mathrel{=}\mathbf{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{char}\;\text{\tt '\char92 \char92 '}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{spaces}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{v}\leftarrow \Varid{parseName}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{modifyScope}\;(\Varid{v}\mathbin{:}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{spaces}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{char}\;\text{\tt '.'}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{spaces}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{term}\leftarrow \Varid{parseTerm}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{modifyScope}\;\Varid{tail}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{pos}\leftarrow \Varid{getPosition}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\;(\Conid{Abs}\;(\Varid{loc}\;\Varid{pos})\;\Varid{v}\;\Varid{term}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{parseVar}\mathbin{::}\Conid{Parser}{}\<[E]%
\\
\>[B]{}\Varid{parseVar}\mathrel{=}\mathbf{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{v}\leftarrow \Varid{parseName}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\Varid{scope},\Varid{syms})\leftarrow \Varid{getState}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{case}\;(\Varid{elemIndex}\;\Varid{v}\;\Varid{scope},\Varid{elemIndex}\;\Varid{v}\;\Varid{syms})\;\mathbf{of}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Conid{Just}\;\Varid{n},\anonymous )\to \mathbf{do}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{pos}\leftarrow \Varid{getPosition}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{return}\;(\Conid{Var}\;(\Varid{loc}\;\Varid{pos})\;\Varid{v}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Conid{Nothing},\Conid{Just}\;\Varid{n})\to \mathbf{do}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{pos}\leftarrow \Varid{getPosition}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{return}\;(\Conid{Sym}\;(\Varid{loc}\;\Varid{pos})\;\Varid{v}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\anonymous \to \Varid{fail}\;(\text{\tt \char34 Variable~`\char34}\plus \Varid{v}\plus \text{\tt \char34 '~is~not~in~scope.\char34}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{parseTerm}\mathbin{::}\Conid{Parser}{}\<[E]%
\\
\>[B]{}\Varid{parseTerm}\mathrel{=}\Varid{chainl1}\;\Varid{parts}\;(\Varid{space}\sequ \Varid{getPosition}\bind (\Varid{return}\mathbin{\circ}\Conid{App}\mathbin{\circ}\Varid{loc})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{parens}\mathbin{::}\Conid{Parsec}\;\Conid{String}\;\Varid{u}\;\Varid{a}\to \Conid{Parsec}\;\Conid{String}\;\Varid{u}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{parens}\mathrel{=}\Varid{between}\;(\Varid{char}\;\text{\tt '('})\;(\Varid{char}\;\text{\tt ')'}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{parts}\mathbin{::}\Conid{Parser}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{parts}\mathrel{=}\Varid{parens}\;\Varid{parseTerm}\mathbin{<|>}\Varid{parseAbs}\;\Varid{parseTerm}\mathbin{<|>}\Varid{parseVar}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{parse}\mathbin{::}\Conid{String}\to \Conid{Either}\;[\mskip1.5mu \Conid{String}\mskip1.5mu]\;\Conid{Term}{}\<[E]%
\\
\>[B]{}\Varid{parse}\mathrel{=}\Varid{parseWithSymbols}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{parseWithSymbols}\mathbin{::}[\mskip1.5mu \Conid{Name}\mskip1.5mu]\to \Conid{String}\to \Conid{Either}\;[\mskip1.5mu \Conid{String}\mskip1.5mu]\;\Conid{Term}{}\<[E]%
\\
\>[B]{}\Varid{parseWithSymbols}\;\Varid{syms}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{either}\;(\Conid{Left}\mathbin{\circ}(\mathbin{:}[\mskip1.5mu \mskip1.5mu])\mathbin{\circ}\Varid{show})\;(\Conid{Right}\mathbin{\circ}\Varid{id})\mathbin{\circ}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{runParser}\;\Varid{parseTerm}\;([\mskip1.5mu \mskip1.5mu],\Varid{syms})\;\text{\tt \char34 <INPUT>\char34}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Printing $\lambda$-calculus terms with names}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{format}\mathbin{::}\Conid{Term}\to \Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{format}\mathrel{=}\Varid{fmt}\;\mathrm{0}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fmt}\;\anonymous \;(\Conid{Var}\;\Varid{n})\mathrel{=}\Varid{n}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fmt}\;\Varid{p}\;(\Conid{Abs}\;\Varid{n}\;\Varid{t})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{let}\;\Varid{b}\mathrel{=}\Varid{mconcat}\;[\mskip1.5mu \text{\tt \char34 \char92 \char92 \char34},\Varid{n},\text{\tt \char34 .\char34},\Varid{fmt}\;\mathrm{1}\;\Varid{t}\mskip1.5mu]{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{in}\;\mathbf{if}\;\Varid{p}\mathbin{>}\mathrm{1}\;\mathbf{then}\;\text{\tt \char34 (\char34}\plus \Varid{b}\plus \text{\tt \char34 )\char34}\;\mathbf{else}\;\Varid{b}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fmt}\;\Varid{p}\;(\Conid{App}\;\Varid{m}\;\Varid{n})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{let}\;\Varid{b}\mathrel{=}\Varid{mconcat}\;[\mskip1.5mu \Varid{fmt}\;\mathrm{2}\;\Varid{m},\text{\tt \char34 ~\char34},\Varid{fmt}\;\mathrm{2}\;\Varid{n}\mskip1.5mu]{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{in}\;\mathbf{if}\;\Varid{p}\geq \mathrm{2}\;\mathbf{then}\;\text{\tt \char34 (\char34}\plus \Varid{b}\plus \text{\tt \char34 )\char34}\;\mathbf{else}\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Printing $\lambda$-calculus terms with de Bruijn indices}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{format}\mathbin{::}\Conid{Term}\to \Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{format}\mathrel{=}\Varid{fmt}\;\mathrm{0}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fmt}\;\anonymous \;(\Conid{Var}\;\Varid{n})\mathrel{=}\Varid{show}\;\Varid{n}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fmt}\;\Varid{p}\;(\Conid{Abs}\;\Varid{t})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{let}\;\Varid{b}\mathrel{=}\text{\tt \char34 λ.\char34}\plus (\Varid{fmt}\;\mathrm{1}\;\Varid{t}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{in}\;\mathbf{if}\;\Varid{p}\mathbin{>}\mathrm{1}\;\mathbf{then}\;\text{\tt \char34 (\char34}\plus \Varid{b}\plus \text{\tt \char34 )\char34}\;\mathbf{else}\;\Varid{b}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fmt}\;\Varid{p}\;(\Conid{App}\;\Varid{m}\;\Varid{n})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{let}\;\Varid{b}\mathrel{=}\Varid{mconcat}\;[\mskip1.5mu \Varid{fmt}\;\mathrm{3}\;\Varid{m},\text{\tt \char34 ~\char34},\Varid{fmt}\;\mathrm{3}\;\Varid{n}\mskip1.5mu]{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{in}\;\mathbf{if}\;\Varid{p}\mathbin{>}\mathrm{2}\;\mathbf{then}\;\text{\tt \char34 (\char34}\plus \Varid{b}\plus \text{\tt \char34 )\char34}\;\mathbf{else}\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\end{document}
